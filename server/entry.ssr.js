import{p as d,q as se,s as oe,t as ie,F as G,v as ae,c as le,i as ce,d as k,_ as g,R as ue,w as fe,Q as de}from"./q-B8t-_BWu.js";const x={manifestHash:"7776yr",core:"q-Cs4701wn.js",preloader:"q-CjL2eSnZ.js",qwikLoader:"q-naDMFAHy.js",bundleGraphAsset:"assets/BI_fFvhi-bundle-graph.json",injections:[{tag:"link",location:"head",attributes:{rel:"stylesheet",href:"/assets/CCP4khVl-style.css"}}],mapping:{s_0HsrnZASxuc:"q-DLI703xv.js",s_5Lvx6kgio0M:"q-Bary3DcS.js",s_6CB3aW7n0m8:"q-C5eVsAHS.js",s_8gOet0VCEi8:"q-BRzKZ8EW.js",s_Cuzh0ralVH4:"q-D1Yswpsg.js",s_DbgKp06WtOA:"q-bKRDDGB9.js",s_Jmt4uzYCn44:"q-C5eVsAHS.js",s_Lg7YL0e6p6c:"q-BhLl4O4z.js",s_MgE09QEpJYM:"q-C5eVsAHS.js",s_Na4LkDSWvEk:"q-DzJmsSlD.js",s_TQP61VngXwg:"q-CGg2DPXC.js",s_gxlO0P8RBXI:"q-CGg2DPXC.js",s_pOduDPYSpps:"q-DnXGg_VF.js",s_xHubcWYnB5Y:"q-C5eVsAHS.js",s_yXB08HkKk08:"q-B0-bRqHc.js",s_PBPpZVyasrQ:"q-B0-bRqHc.js",s_pjGN70bvh4w:"q-B0-bRqHc.js",s_xsUAvAkry8w:"q-B0-bRqHc.js",s_MExkSDs21qc:"q-B0-bRqHc.js",s_m5DKwlzIxUk:"q-B0-bRqHc.js",s_NCjkAmay0GE:"q-D_op3ef3.js",s_QBwZ7ik2uhM:"q-D_op3ef3.js",s_lSNVxRMsRF8:"q-B0-bRqHc.js",s_F7jRhqn2hBo:"q-Bary3DcS.js",s_9zYiL0zYTxo:"q-DnXGg_VF.js",s_N6EoSvn9wfI:"q-u2jzQhib.js",s_OINLBiZZ10I:"q-DnXGg_VF.js",s_UadoNUt8dNg:"q-C0-H8QPn.js",s_JewQJzKUL9U:"q-B-9Q2_66.js",s_5mDmoB44rmo:"q-1v1SKWpY.js",s_914vtnbtqPs:"q-C5eVsAHS.js",s_DXtcokToQ2A:"q-BhLl4O4z.js",s_G2f5FBocVRY:"q-BfuPI2Tr.js",s_aJ0tKvBtubo:"q-u2jzQhib.js",s_yY1kDrAKT60:"q-B4gXa4xZ.js",s_0hNcjbVrb24:"q-DnXGg_VF.js",s_4egpBoQ5P6E:"q-DhIz39yM.js",s_6VfADlAOtq0:"q-OzlC1145.js",s_804HSXJK28Q:"q-D_op3ef3.js",s_FHhLXfDqkKU:"q-B4gXa4xZ.js",s_HrURCLKzLNQ:"q-BesfksLy.js",s_JCqeIS7vC6g:"q-B0-bRqHc.js",s_K6hx0f8WI3Y:"q-CN6a_MtL.js",s_KMAZVCZ6QgE:"q-bKRDDGB9.js",s_LkS1RzSP2EQ:"q-DLI703xv.js",s_MaCkYfUZS8Q:"q-u2jzQhib.js",s_RRBIykyPb0g:"q-DrVcC0HD.js",s_ZhjK60ORuFA:"q-C5eVsAHS.js",s_bz9jY5SeAVo:"q-BHg_YWfq.js",s_jKA4cDOlZt8:"q-D85_px-B.js",s_jnuqaatLe04:"q-CoburqtC.js",s_kNMm6vY6iUY:"q-CSLEOHWv.js",s_tPFQEvWvtXM:"q-DCmO2JPx.js",s_wXOnJxM4iO8:"q-Dx84GFMP.js",s_2udZ0itPfxo:"q-C5eVsAHS.js",s_5dq7tnXqo2c:"q-C5eVsAHS.js",s_Bd3CYoFfGcU:"q-B0-bRqHc.js",s_Ic6iV4mql28:"q-C5eVsAHS.js",s_L3DdEmFImnI:"q-DrVcC0HD.js",s_NGvIQ3Z0M0k:"q-D1Yswpsg.js",s_YF08dhaE9y8:"q-BRzKZ8EW.js",s_bQSgDjfd064:"q-Bary3DcS.js",s_rp0viGqaGJY:"q-CGg2DPXC.js",s_t1ZbimrNK0Q:"q-D1Yswpsg.js",s_wQQ04QMUrMs:"q-CKe1UrnI.js",s_9UY5VlzvgOw:"q-DARzXjrW.js",s_EE0SYCk14e0:"q-CeWuwsOi.js",s_NYrp4EzrtPk:"q-BfuPI2Tr.js",s_O8kBrgl6Pmw:"q-9stOHcwc.js",s_PEhsOIRRTkA:"q-CXZSoQli.js",s_R3soB0Gc0FA:"q-BCJuhmPl.js",s_UceUcoQDRmQ:"q-1v1SKWpY.js",s_UiK4lX6a5E4:"q-CGg2DPXC.js",s_XitXPq48qng:"q-DqZNTG9J.js",s_ac1qSRpZQNg:"q-CKe1UrnI.js",s_cziuJ4tAEBI:"q-Bary3DcS.js",s_gSTLnQhzfNY:"q-CXXktnOC.js",s_j1E0uaj4zEo:"q-D1Yswpsg.js",s_qIIA0R0rUu4:"q-BRzKZ8EW.js",s_rrFd0NdNtdY:"q-B3r-gxSp.js",s_sN348LH5AHY:"q-C0-H8QPn.js",s_t6DmHieuV08:"q-DOKReMd8.js",s_td30QSVx0zQ:"q-iZIgFBNK.js",s_vbpqL4L300U:"q-BhLl4O4z.js",s_IeK3mNx60Gc:"q-C0-H8QPn.js",s_0pDraI2m0Xo:"q-Brjpjfzw.js",s_Mi2UnVJqrsU:"q-CA3uk-31.js",s_X2M8ctUd0qE:"q-C-FbRTI4.js",s_eNeFvcmSYD8:"q-CumQa7mT.js",s_3TxeGR8DMIo:"q-BfuPI2Tr.js",s_4kqmbMLejQg:"q-BfuPI2Tr.js",s_59eQ3yx50uU:"q-iZIgFBNK.js",s_69gEyyV1fuc:"q-9stOHcwc.js",s_7TaJ1TwXnmM:"q-BhLl4O4z.js",s_DyXZ6zZMg0Q:"q-B0-bRqHc.js",s_IId5lAFSg84:"q-C0-H8QPn.js",s_NlljuhSvwJw:"q-CGg2DPXC.js",s_OBKSvoc5irk:"q-C5eVsAHS.js",s_ObBuPk5OfOQ:"q-CXZSoQli.js",s_OdZINRNfRIA:"q-D1Yswpsg.js",s_T7xHKXjb350:"q-CKe1UrnI.js",s_Vp78rFxZ0s0:"q-C5eVsAHS.js",s_YEjK8XHIBVU:"q-BfuPI2Tr.js",s_YU0FmKpuxz8:"q-CXZSoQli.js",s_YrT0fNPcpHg:"q-D1Yswpsg.js",s_aFvCGGBE3kM:"q-D1Yswpsg.js",s_eMnzRpMBMBo:"q-C5eVsAHS.js",s_rGG7Bjycvfw:"q-C0-H8QPn.js",s_ucg5LwsbGBs:"q-B0-bRqHc.js",s_xKXe742sL9c:"q-C5eVsAHS.js"}};/**
 * @license
 * @builder.io/qwik/server 1.17.0
 * Copyright Builder.io, Inc. All Rights Reserved.
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/QwikDev/qwik/blob/main/LICENSE
 */var me=(e=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(t,n)=>(typeof require<"u"?require:t)[n]}):e)(function(e){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')}),pe="<sync>";function he(e,t){const n=t?.mapper,r=e.symbolMapper?e.symbolMapper:(s,i,a)=>{if(n){const l=B(s),c=n[l];if(!c){if(l===pe)return[l,""];if(globalThis.__qwik_reg_symbols?.has(l))return[s,"_"];if(a)return[s,`${a}?qrl=${s}`];console.error("Cannot resolve symbol",s,"in",n,a)}return c}};return{isServer:!0,async importSymbol(s,i,a){const l=B(a),c=globalThis.__qwik_reg_symbols?.get(l);if(c)return c;let u=String(i);u.endsWith(".js")||(u+=".js");const m=me(u);if(!(a in m))throw new Error(`Q-ERROR: missing symbol '${a}' in module '${u}'.`);return m[a]},raf:()=>(console.error("server can not rerender"),Promise.resolve()),nextTick:s=>new Promise(i=>{setTimeout(()=>{i(s())})}),chunkForSymbol(s,i,a){return r(s,n,a)}}}async function be(e,t){const n=he(e,t);oe(n)}var B=e=>{const t=e.lastIndexOf("_");return t>-1?e.slice(t+1):e},qe="q:instance",L={$DEBUG$:!1,$invPreloadProbability$:.65},ve=Date.now(),_e=/\.[mc]?js$/,K=0,ye=1,ge=2,je=3,O,H,we=(e,t)=>({$name$:e,$state$:_e.test(e)?K:je,$deps$:Z?t?.map(n=>({...n,$factor$:1})):t,$inverseProbability$:1,$createdTs$:Date.now(),$waitedMs$:0,$loadedMs$:0}),Se=e=>{const t=new Map;let n=0;for(;n<e.length;){const r=e[n++],o=[];let s,i=1;for(;s=e[n],typeof s=="number";)s<0?i=-s/10:o.push({$name$:e[s],$importProbability$:i,$factor$:1}),n++;t.set(r,o)}return t},X=e=>{let t=Q.get(e);if(!t){let n;if(H){if(n=H.get(e),!n)return;n.length||(n=void 0)}t=we(e,n),Q.set(e,t)}return t},Pe=(e,t)=>{t&&("debug"in t&&(L.$DEBUG$=!!t.debug),typeof t.preloadProbability=="number"&&(L.$invPreloadProbability$=1-t.preloadProbability)),!(O!=null||!e)&&(O="",H=Se(e))},Q=new Map,Z,D,J=0,P=[],$e=(...e)=>{console.log(`Preloader ${Date.now()-ve}ms ${J}/${P.length} queued>`,...e)},Ee=()=>{Q.clear(),D=!1,Z=!0,J=0,P.length=0},Ce=()=>{D&&(P.sort((e,t)=>e.$inverseProbability$-t.$inverseProbability$),D=!1)},ke=()=>{Ce();let e=.4;const t=[];for(const n of P){const r=Math.round((1-n.$inverseProbability$)*10);r!==e&&(e=r,t.push(e)),t.push(n.$name$)}return t},W=(e,t,n)=>{if(n?.has(e))return;const r=e.$inverseProbability$;if(e.$inverseProbability$=t,!(r-e.$inverseProbability$<.01)&&(O!=null&&e.$state$<ge&&(e.$state$===K&&(e.$state$=ye,P.push(e),L.$DEBUG$&&$e(`queued ${Math.round((1-e.$inverseProbability$)*100)}%`,e.$name$)),D=!0),e.$deps$)){n||(n=new Set),n.add(e);const o=1-e.$inverseProbability$;for(const s of e.$deps$){const i=X(s.$name$);if(i.$inverseProbability$===0)continue;let a;if(o===1||o>=.99&&T<100)T++,a=Math.min(.01,1-s.$importProbability$);else{const l=1-s.$importProbability$*o,c=s.$factor$,u=l/c;a=Math.max(.02,i.$inverseProbability$*u),s.$factor$=u}W(i,a,n)}}},U=(e,t)=>{const n=X(e);n&&n.$inverseProbability$>t&&W(n,t)},T,Be=(e,t)=>{if(!e?.length)return;T=0;let n=t?1-t:.4;if(Array.isArray(e))for(let r=e.length-1;r>=0;r--){const o=e[r];typeof o=="number"?n=1-o/10:U(o,n)}else U(e,n)};function De(e){const t=[],n=r=>{if(r)for(const o of r)t.includes(o.url)||(t.push(o.url),o.imports&&n(o.imports))};return n(e),t}var Ae=e=>{const t=ae();return e?.qrls?.map(n=>{const r=n.$refSymbol$||n.$symbol$,o=n.$chunk$,s=t.chunkForSymbol(r,o,n.dev?.file);return s?s[1]:o}).filter(Boolean)};function Ie(e,t,n){const r=t.prefetchStrategy;if(r===null)return[];if(!n?.manifest.bundleGraph)return Ae(e);if(typeof r?.symbolsToPrefetch=="function")try{const s=r.symbolsToPrefetch({manifest:n.manifest});return De(s)}catch(s){console.error("getPrefetchUrls, symbolsToPrefetch()",s)}const o=new Set;for(const s of e?.qrls||[]){const i=B(s.$refSymbol$||s.$symbol$);i&&i.length>=10&&o.add(i)}return[...o]}var Ne=(e,t)=>{if(!t?.manifest.bundleGraph)return[...new Set(e)];Ee();let n=.99;for(const r of e.slice(0,15))Be(r,n),n*=.85;return ke()},F=(e,t)=>{if(t==null)return null;const n=`${e}${t}`.split("/"),r=[];for(const o of n)o===".."&&r.length>0?r.pop():r.push(o);return r.join("/")},Re=(e,t,n,r,o)=>{const s=F(e,t?.manifest?.preloader),i="/"+t?.manifest.bundleGraphAsset;if(s&&i&&n!==!1){const l=typeof n=="object"?{debug:n.debug,preloadProbability:n.ssrPreloadProbability}:void 0;Pe(t?.manifest.bundleGraph,l);const c=[];n?.debug&&c.push("d:1"),n?.maxIdlePreloads&&c.push(`P:${n.maxIdlePreloads}`),n?.preloadProbability&&c.push(`Q:${n.preloadProbability}`);const u=c.length?`,{${c.join(",")}}`:"",m=`let b=fetch("${i}");import("${s}").then(({l})=>l(${JSON.stringify(e)},b${u}));`;r.push(d("link",{rel:"modulepreload",href:s,nonce:o}),d("link",{rel:"preload",href:i,as:"fetch",crossorigin:"anonymous",nonce:o}),d("script",{type:"module",async:!0,dangerouslySetInnerHTML:m,nonce:o}))}const a=F(e,t?.manifest.core);a&&r.push(d("link",{rel:"modulepreload",href:a,nonce:o}))},xe=(e,t,n,r,o)=>{if(r.length===0||n===!1)return null;const{ssrPreloads:s,ssrPreloadProbability:i}=Oe(typeof n=="boolean"?void 0:n);let a=s;const l=[],c=[],u=t?.manifest.manifestHash;if(a){const v=t?.manifest.preloader,p=t?.manifest.core,b=Ne(r,t);let w=4;const $=i*10;for(const q of b)if(typeof q=="string"){if(w<$)break;if(q===v||q===p)continue;if(c.push(q),--a===0)break}else w=q}const m=F(e,u&&t?.manifest.preloader);let j=c.length?`${JSON.stringify(c)}.map((l,e)=>{e=document.createElement('link');e.rel='modulepreload';e.href=${JSON.stringify(e)}+l;document.head.appendChild(e)});`:"";return m&&(j+=`window.addEventListener('load',f=>{f=_=>import("${m}").then(({p})=>p(${JSON.stringify(r)}));try{requestIdleCallback(f,{timeout:2000})}catch(e){setTimeout(f,200)}})`),j&&l.push(d("script",{type:"module","q:type":"preload",async:!0,dangerouslySetInnerHTML:j,nonce:o})),l.length>0?d(G,{children:l}):null},Le=(e,t,n,r,o)=>{if(n.preloader!==!1){const s=Ie(t,n,r);if(s.length>0){const i=xe(e,r,n.preloader,s,n.serverData?.nonce);i&&o.push(i)}}};function Oe(e){return{...He,...e}}var He={ssrPreloads:7,ssrPreloadProbability:.5,debug:!1,maxIdlePreloads:25,preloadProbability:.35},Qe='const t=document,e=window,n=new Set,o=new Set([t]);let r;const s=(t,e)=>Array.from(t.querySelectorAll(e)),a=t=>{const e=[];return o.forEach(n=>e.push(...s(n,t))),e},i=t=>{w(t),s(t,"[q\\\\:shadowroot]").forEach(t=>{const e=t.shadowRoot;e&&i(e)})},c=t=>t&&"function"==typeof t.then,l=(t,e,n=e.type)=>{a("[on"+t+"\\\\:"+n+"]").forEach(o=>{b(o,t,e,n)})},f=e=>{if(void 0===e._qwikjson_){let n=(e===t.documentElement?t.body:e).lastElementChild;for(;n;){if("SCRIPT"===n.tagName&&"qwik/json"===n.getAttribute("type")){e._qwikjson_=JSON.parse(n.textContent.replace(/\\\\x3C(\\/?script)/gi,"<$1"));break}n=n.previousElementSibling}}},p=(t,e)=>new CustomEvent(t,{detail:e}),b=async(e,n,o,r=o.type)=>{const s="on"+n+":"+r;e.hasAttribute("preventdefault:"+r)&&o.preventDefault(),e.hasAttribute("stoppropagation:"+r)&&o.stopPropagation();const a=e._qc_,i=a&&a.li.filter(t=>t[0]===s);if(i&&i.length>0){for(const t of i){const n=t[1].getFn([e,o],()=>e.isConnected)(o,e),r=o.cancelBubble;c(n)&&await n,r&&o.stopPropagation()}return}const l=e.getAttribute(s);if(l){const n=e.closest("[q\\\\:container]"),r=n.getAttribute("q:base"),s=n.getAttribute("q:version")||"unknown",a=n.getAttribute("q:manifest-hash")||"dev",i=new URL(r,t.baseURI);for(const p of l.split("\\n")){const l=new URL(p,i),b=l.href,h=l.hash.replace(/^#?([^?[|]*).*$/,"$1")||"default",q=performance.now();let _,d,y;const w=p.startsWith("#"),g={qBase:r,qManifest:a,qVersion:s,href:b,symbol:h,element:e,reqTime:q};if(w){const e=n.getAttribute("q:instance");_=(t["qFuncs_"+e]||[])[Number.parseInt(h)],_||(d="sync",y=Error("sym:"+h))}else{u("qsymbol",g);const t=l.href.split("#")[0];try{const e=import(t);f(n),_=(await e)[h],_||(d="no-symbol",y=Error(`${h} not in ${t}`))}catch(t){d||(d="async"),y=t}}if(!_){u("qerror",{importError:d,error:y,...g}),console.error(y);break}const m=t.__q_context__;if(e.isConnected)try{t.__q_context__=[e,o,l];const n=_(o,e);c(n)&&await n}catch(t){u("qerror",{error:t,...g})}finally{t.__q_context__=m}}}},u=(e,n)=>{t.dispatchEvent(p(e,n))},h=t=>t.replace(/([A-Z])/g,t=>"-"+t.toLowerCase()),q=async t=>{let e=h(t.type),n=t.target;for(l("-document",t,e);n&&n.getAttribute;){const o=b(n,"",t,e);let r=t.cancelBubble;c(o)&&await o,r||(r=r||t.cancelBubble||n.hasAttribute("stoppropagation:"+t.type)),n=t.bubbles&&!0!==r?n.parentElement:null}},_=t=>{l("-window",t,h(t.type))},d=()=>{const s=t.readyState;if(!r&&("interactive"==s||"complete"==s)&&(o.forEach(i),r=1,u("qinit"),(e.requestIdleCallback??e.setTimeout).bind(e)(()=>u("qidle")),n.has("qvisible"))){const t=a("[on\\\\:qvisible]"),e=new IntersectionObserver(t=>{for(const n of t)n.isIntersecting&&(e.unobserve(n.target),b(n.target,"",p("qvisible",n)))});t.forEach(t=>e.observe(t))}},y=(t,e,n,o=!1)=>{t.addEventListener(e,n,{capture:o,passive:!1})},w=(...t)=>{for(const r of t)"string"==typeof r?n.has(r)||(o.forEach(t=>y(t,r,q,!0)),y(e,r,_,!0),n.add(r)):o.has(r)||(n.forEach(t=>y(r,t,q,!0)),o.add(r))};if(!("__q_context__"in t)){t.__q_context__=0;const r=e.qwikevents;r&&(Array.isArray(r)?w(...r):w("click","input")),e.qwikevents={events:n,roots:o,push:w},y(t,"readystatechange",d),d()}',Te=`const doc = document;
const win = window;
const events = /* @__PURE__ */ new Set();
const roots = /* @__PURE__ */ new Set([doc]);
let hasInitialized;
const nativeQuerySelectorAll = (root, selector) => Array.from(root.querySelectorAll(selector));
const querySelectorAll = (query) => {
  const elements = [];
  roots.forEach((root) => elements.push(...nativeQuerySelectorAll(root, query)));
  return elements;
};
const findShadowRoots = (fragment) => {
  processEventOrNode(fragment);
  nativeQuerySelectorAll(fragment, "[q\\\\:shadowroot]").forEach((parent) => {
    const shadowRoot = parent.shadowRoot;
    shadowRoot && findShadowRoots(shadowRoot);
  });
};
const isPromise = (promise) => promise && typeof promise.then === "function";
const broadcast = (infix, ev, type = ev.type) => {
  querySelectorAll("[on" + infix + "\\\\:" + type + "]").forEach((el) => {
    dispatch(el, infix, ev, type);
  });
};
const resolveContainer = (containerEl) => {
  if (containerEl._qwikjson_ === void 0) {
    const parentJSON = containerEl === doc.documentElement ? doc.body : containerEl;
    let script = parentJSON.lastElementChild;
    while (script) {
      if (script.tagName === "SCRIPT" && script.getAttribute("type") === "qwik/json") {
        containerEl._qwikjson_ = JSON.parse(
          script.textContent.replace(/\\\\x3C(\\/?script)/gi, "<$1")
        );
        break;
      }
      script = script.previousElementSibling;
    }
  }
};
const createEvent = (eventName, detail) => new CustomEvent(eventName, {
  detail
});
const dispatch = async (element, onPrefix, ev, eventName = ev.type) => {
  const attrName = "on" + onPrefix + ":" + eventName;
  if (element.hasAttribute("preventdefault:" + eventName)) {
    ev.preventDefault();
  }
  if (element.hasAttribute("stoppropagation:" + eventName)) {
    ev.stopPropagation();
  }
  const ctx = element._qc_;
  const relevantListeners = ctx && ctx.li.filter((li) => li[0] === attrName);
  if (relevantListeners && relevantListeners.length > 0) {
    for (const listener of relevantListeners) {
      const results = listener[1].getFn([element, ev], () => element.isConnected)(ev, element);
      const cancelBubble = ev.cancelBubble;
      if (isPromise(results)) {
        await results;
      }
      if (cancelBubble) {
        ev.stopPropagation();
      }
    }
    return;
  }
  const attrValue = element.getAttribute(attrName);
  if (attrValue) {
    const container = element.closest("[q\\\\:container]");
    const qBase = container.getAttribute("q:base");
    const qVersion = container.getAttribute("q:version") || "unknown";
    const qManifest = container.getAttribute("q:manifest-hash") || "dev";
    const base = new URL(qBase, doc.baseURI);
    for (const qrl of attrValue.split("\\n")) {
      const url = new URL(qrl, base);
      const href = url.href;
      const symbol = url.hash.replace(/^#?([^?[|]*).*$/, "$1") || "default";
      const reqTime = performance.now();
      let handler;
      let importError;
      let error;
      const isSync = qrl.startsWith("#");
      const eventData = {
        qBase,
        qManifest,
        qVersion,
        href,
        symbol,
        element,
        reqTime
      };
      if (isSync) {
        const hash = container.getAttribute("q:instance");
        handler = (doc["qFuncs_" + hash] || [])[Number.parseInt(symbol)];
        if (!handler) {
          importError = "sync";
          error = new Error("sym:" + symbol);
        }
      } else {
        emitEvent("qsymbol", eventData);
        const uri = url.href.split("#")[0];
        try {
          const module = import(
                        uri
          );
          resolveContainer(container);
          handler = (await module)[symbol];
          if (!handler) {
            importError = "no-symbol";
            error = new Error(\`\${symbol} not in \${uri}\`);
          }
        } catch (err) {
          importError || (importError = "async");
          error = err;
        }
      }
      if (!handler) {
        emitEvent("qerror", {
          importError,
          error,
          ...eventData
        });
        console.error(error);
        break;
      }
      const previousCtx = doc.__q_context__;
      if (element.isConnected) {
        try {
          doc.__q_context__ = [element, ev, url];
          const results = handler(ev, element);
          if (isPromise(results)) {
            await results;
          }
        } catch (error2) {
          emitEvent("qerror", { error: error2, ...eventData });
        } finally {
          doc.__q_context__ = previousCtx;
        }
      }
    }
  }
};
const emitEvent = (eventName, detail) => {
  doc.dispatchEvent(createEvent(eventName, detail));
};
const camelToKebab = (str) => str.replace(/([A-Z])/g, (a) => "-" + a.toLowerCase());
const processDocumentEvent = async (ev) => {
  let type = camelToKebab(ev.type);
  let element = ev.target;
  broadcast("-document", ev, type);
  while (element && element.getAttribute) {
    const results = dispatch(element, "", ev, type);
    let cancelBubble = ev.cancelBubble;
    if (isPromise(results)) {
      await results;
    }
    cancelBubble || (cancelBubble = cancelBubble || ev.cancelBubble || element.hasAttribute("stoppropagation:" + ev.type));
    element = ev.bubbles && cancelBubble !== true ? element.parentElement : null;
  }
};
const processWindowEvent = (ev) => {
  broadcast("-window", ev, camelToKebab(ev.type));
};
const processReadyStateChange = () => {
  const readyState = doc.readyState;
  if (!hasInitialized && (readyState == "interactive" || readyState == "complete")) {
    roots.forEach(findShadowRoots);
    hasInitialized = 1;
    emitEvent("qinit");
    const riC = win.requestIdleCallback ?? win.setTimeout;
    riC.bind(win)(() => emitEvent("qidle"));
    if (events.has("qvisible")) {
      const results = querySelectorAll("[on\\\\:qvisible]");
      const observer = new IntersectionObserver((entries) => {
        for (const entry of entries) {
          if (entry.isIntersecting) {
            observer.unobserve(entry.target);
            dispatch(entry.target, "", createEvent("qvisible", entry));
          }
        }
      });
      results.forEach((el) => observer.observe(el));
    }
  }
};
const addEventListener = (el, eventName, handler, capture = false) => {
  el.addEventListener(eventName, handler, { capture, passive: false });
};
const processEventOrNode = (...eventNames) => {
  for (const eventNameOrNode of eventNames) {
    if (typeof eventNameOrNode === "string") {
      if (!events.has(eventNameOrNode)) {
        roots.forEach(
          (root) => addEventListener(root, eventNameOrNode, processDocumentEvent, true)
        );
        addEventListener(win, eventNameOrNode, processWindowEvent, true);
        events.add(eventNameOrNode);
      }
    } else {
      if (!roots.has(eventNameOrNode)) {
        events.forEach(
          (eventName) => addEventListener(eventNameOrNode, eventName, processDocumentEvent, true)
        );
        roots.add(eventNameOrNode);
      }
    }
  }
};
if (!("__q_context__" in doc)) {
  doc.__q_context__ = 0;
  const qwikevents = win.qwikevents;
  if (qwikevents) {
    if (Array.isArray(qwikevents)) {
      processEventOrNode(...qwikevents);
    } else {
      processEventOrNode("click", "input");
    }
  }
  win.qwikevents = {
    events,
    roots,
    push: processEventOrNode
  };
  addEventListener(doc, "readystatechange", processReadyStateChange);
  processReadyStateChange();
}`;function Fe(e={}){return e.debug?Te:Qe}function R(){if(typeof performance>"u")return()=>0;const e=performance.now();return()=>(performance.now()-e)/1e6}function Me(e){let t=e.base;return typeof e.base=="function"&&(t=e.base(e)),typeof t=="string"?(t.endsWith("/")||(t+="/"),t):"/build/"}var Ve="<!DOCTYPE html>";async function Ye(e,t){let n=t.stream,r=0,o=0,s=0,i=0,a="",l;const c=t.streaming?.inOrder??{strategy:"auto",maximunInitialChunk:5e4,maximunChunk:3e4},u=t.containerTagName??"html",m=t.containerAttributes??{},A=n,j=R(),v=Me(t),p=Ue(t.manifest),b=t.serverData?.nonce;function w(){a&&(A.write(a),a="",r=0,s++,s===1&&(i=j()))}function $(f){const h=f.length;r+=h,o+=h,a+=f}switch(c.strategy){case"disabled":n={write:$};break;case"direct":n=A;break;case"auto":let f=0,h=!1;const Y=c.maximunChunk??0,N=c.maximunInitialChunk??0;n={write(_){_==="<!--qkssr-f-->"?h||(h=!0):_==="<!--qkssr-pu-->"?f++:_==="<!--qkssr-po-->"?f--:$(_),f===0&&(h||r>=(s===0?N:Y))&&(h=!1,w())}};break}u==="html"?n.write(Ve):n.write("<!--cq-->"),p||console.warn("Missing client manifest, loading symbols in the client might 404. Please ensure the client build has run and generated the manifest for the server build."),await be(t,p);const q=p?.manifest.injections,E=q?q.map(f=>d(f.tag,f.attributes??{})):[];let C=t.qwikLoader?typeof t.qwikLoader=="object"?t.qwikLoader.include==="never"?2:0:t.qwikLoader==="inline"?1:t.qwikLoader==="never"?2:0:0;const I=p?.manifest.qwikLoader;if(C===0&&!I&&(C=1),C===0)E.unshift(d("link",{rel:"modulepreload",href:`${v}${I}`,nonce:b}),d("script",{type:"module",async:!0,src:`${v}${I}`,nonce:b}));else if(C===1){const f=Fe({debug:t.debug});E.unshift(d("script",{id:"qwikloader",type:"module",async:!0,nonce:b,dangerouslySetInnerHTML:f}))}Re(v,p,t.preloader,E,b);const ee=R(),te=[];let M=0,V=0;await se(e,{stream:n,containerTagName:u,containerAttributes:m,serverData:t.serverData,base:v,beforeContent:E,beforeClose:async(f,h,Y,N)=>{M=ee();const _=R();l=await ie(f,h,void 0,N);const y=[];Le(v,l,t,p,y);const re=JSON.stringify(l.state,void 0,void 0);if(y.push(d("script",{type:"qwik/json",dangerouslySetInnerHTML:Ge(re),nonce:b})),l.funcs.length>0){const S=m[qe];y.push(d("script",{"q:func":"qwik/json",dangerouslySetInnerHTML:Ze(S,l.funcs),nonce:b}))}const z=Array.from(h.$events$,S=>JSON.stringify(S));if(z.length>0){const S=`(window.qwikevents||(window.qwikevents=[])).push(${z.join(",")})`;y.push(d("script",{dangerouslySetInnerHTML:S,nonce:b}))}return Ke(te,f),V=_(),d(G,{children:y})},manifestHash:p?.manifest.manifestHash||"dev"+ze()}),u!=="html"&&n.write("<!--/cq-->"),w();const ne=l.resources.some(f=>f._cache!==1/0);return{prefetchResources:void 0,snapshotResult:l,flushes:s,manifest:p?.manifest,size:o,isStatic:!ne,timing:{render:M,snapshot:V,firstFlush:i}}}function ze(){return Math.random().toString(36).slice(2)}function Ue(e){const t=e?{...x,...e}:x;if(!t||"mapper"in t)return t;if(t.mapping){const n={};return Object.entries(t.mapping).forEach(([r,o])=>{n[B(r)]=[r,o]}),{mapper:n,manifest:t,injections:t.injections||[]}}}var Ge=e=>e.replace(/<(\/?script)/gi,"\\x3C$1");function Ke(e,t){for(const n of t){const r=n.$componentQrl$?.getSymbol();r&&!e.includes(r)&&e.push(r)}}var Xe='document["qFuncs_HASH"]=';function Ze(e,t){return Xe.replace("HASH",e)+`[${t.join(`,
`)}]`}const Je=()=>k(de,{children:[g("head",null,null,[g("meta",null,{charSet:"utf-8"},null,3,null),g("meta",null,{name:"viewport",content:"width=device-width, initial-scale=1"},null,3,null),g("link",null,{rel:"manifest",href:"/manifest.json"},null,3,null),g("link",null,{rel:"icon",type:"image/svg+xml",href:"https://media.jpstas.com/assets/SVG%20Icons.svg"},null,3,null)],3,null),g("body",null,null,[k(ue,null,3,"14_0"),k(fe,null,3,"14_1")],1,null)]},1,"14_2"),We=le(ce(Je,"s_gSTLnQhzfNY"));function nt(e){return Ye(k(We,null,3,"Y1_0"),{manifest:x,...e,containerAttributes:{lang:"en-us",...e.containerAttributes}})}export{nt as default};
